# docker-compose.yml

version: '3.8'

services:
  db:
    image: mysql:8
    container_name: mysql-db
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: admin
      MYSQL_DATABASE: station_quality_control
      # TZ di sini memastikan CURRENT_TIMESTAMP di DB menggunakan UTC
    volumes:
      - db_data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-padmin"]
      interval: 10s
      timeout: 5s
      retries: 5
      
  redis-cache:
    image: redis:latest
    container_name: redis-cache
    ports:
      - "6379:6379"

  server-app:
    build:
      context: ./server 
      dockerfile: Dockerfile
    container_name: server-app
    ports:
      - "5000:5000"
    env_file:
      - ./server/.env
    environment:
      MYSQL_HOST: db
      # TZ di sini memastikan aplikasi Node.js & cron berjalan dalam UTC
      REDIS_URL: redis://redis-cache:6379
      API_BASE_URL: http://103.169.3.72:2107/api
      API_KEY: DEBUG-BYPASS-TOKEN-2107
    depends_on:
      db:
        condition: service_healthy
      redis-cache:
        condition: service_started
        
    # Ini adalah cara paling andal untuk memastikan urutan eksekusi yang benar:
    # 1. Jalankan db:setup (migrate & seed) terlebih dahulu.
    # 2. Setelah selesai, baru jalankan PM2 untuk memulai server dan scheduler.
    command: sh -c "npm run db:setup && pm2-runtime start ecosystem.config.cjs"

  client:
    build:
      context: ./client
      dockerfile: Dockerfile
    container_name: client-app
    ports:
      - "5173:5173"
    depends_on:
      - server-app
    volumes:
      - ./client:/app
      - /app/node_modules

volumes:
  db_data:
